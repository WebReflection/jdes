self.deejs=function(t){"use strict";
/*!
   * ISC License
   *
   * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */let e=!0;const{isArray:n,prototype:r}=Array,{assign:s,create:c,defineProperty:o,freeze:a,is:i,prototype:l}=Object,{getPrototypeOf:u,ownKeys:h}=Reflect,{concat:f,every:p,filter:y,map:g,push:w,slice:k,splice:b}=r,d="object"==typeof self?self:global,m=new Map,v=new Map,S=new Set,A=new Set,E=new WeakSet,I=t=>String(t).toString(),F=t=>String(t).replace(/^Symbol\(([\s\S]+)\)$/,"[$1]"),U=t=>{const[e]=h(t),n=t[e],r=m.get(e);if(!r)throw new TypeError("unknown type "+F(e));return{_:r,type:e,value:n}},$=(t,e)=>{const r=n(e),s=`expected type ${F(t)} but got ${[r?"array":typeof e,r?g.call(e,I):I(e)].join(": ")}`;throw new TypeError(s)},j=(t,e,n,r,s)=>{o(t,n,{value:(...n)=>T(N(r.apply(t,n),e,s),e,s)})},N=(t,n,r)=>(e&&(j(t,n,"concat",f,r),j(t,n,"filter",y,r),j(t,n,"map",g,r),j(t,n,"slice",k,r),o(t,"push",{value:(...e)=>(r.check(e,!0)||$(n,e),w.apply(t,e))}),o(t,"splice",{value(e,s=0,...c){return r.check(c,!0)||$(n,c),T(N(b.apply(t,arguments),n,r),n,r)}})),t),T=(t,n,r)=>(e&&E.add(t=new Proxy(t,{set(t,e,s){if(r.check(s,!1)||$(n,s),t.length<=e)throw new Error("out of bounds: use push(...values) instead");return t[e]=s,!0}})),t),_=(t,n,r,s)=>{const c=new WeakMap;o(t,n,{enumerable:!0,get(){return c.has(this)?c.get(this):s},set(t){e&&!x({[r]:t})&&$(r,t),c.set(this,t)}})},x=t=>{const{_:e,type:n,value:r}=U(t);return e.check(r,"symbol"==typeof n)},B=(t,r)=>{const c=r===O,a=!c&&S.has(r),i=!c&&!a&&A.has(r);if(!(c||a||i||r.check&&r.cast))throw new Error(`unable to define ${t} without check and cast`);for(const h of[].concat(t)){if(m.has(h)||h in d||h in l)throw new TypeError(F(h)+" already defined");const t=c||a?r(h):i?{check(t,e){return e?p.call(t,t=>this.check(t,!1)):t instanceof r||u(t)===l},cast:t=>t instanceof r?t:new r(t)}:s({},r),f=a?d[h].toString():Symbol(h);a||o(d,h,{configurable:!0,value:f}),m.set(h,t),m.set(f,t),o(l,h,{configurable:!0,get(){return e&&!t.check(this,!1)&&$(h,this),i?t.cast(this):this}}),o(l,f,{configurable:!0,get(){if(e&&!t.check(this,!0)&&$(f,this),v.has(h))return t.cast(this);if(e&&!n(this)&&$(f,this),e&&E.has(this))return this;const r=i?g.call(this,t.cast,t):this;return T(N(r,f,t),h,t)}})}},M=t=>{const[n]=h(t),r=t[n];return function(){const t=r.apply(this,arguments);return e&&!x({[n]:t})&&$(n,t),t}},O=t=>{const n=t.split("_");if(e&&!n.every(t=>m.has(t)))throw new TypeError("unable to define union: "+t);return{check(t,e){return e?p.call(t,t=>this.check(t,!1)):n.some(e=>x({[e]:t}))},cast(e){const r=n.findIndex(t=>x({[t]:e}));return r<0&&$(t,e),m.get(n[r]).cast(e)}}};return[{f32:"Float32Array"},{f64:"Float64Array"},{i8:"Int8Array"},{i16:"Int16Array"},{i32:"Int32Array"},{u8:"Uint8Array"},{u16:"Uint16Array"},{u32:"Uint32Array"},{uc8:"Uint8ClampedArray"},{i64:"BigInt64Array"},{u64:"BigUint64Array"},{double:"Float64Array"}].forEach(t=>{const[e]=h(t),r=d[t[e]];if(r){v.set(e,r);const t=new r(1);B(e,{check:(e,s)=>s?e instanceof r||n(e)&&p.call(new r(e),t=>!isNaN(t)):(t[0]=e,i(t[0],e)),cast:e=>"number"==typeof e?(t[0]=e,t[0]):e instanceof r?e:new r(e)})}}),B("int",{check(t,e){return e?p.call(t,t=>this.check(t,!1)):i(this.cast(t),t)},cast:t=>i(t,-0)?t:parseInt(t,10)||0}),B("float",{check(t,e){return e?p.call(t,t=>this.check(t,!1)):i(this.cast(t),t)},cast:t=>i(t,-0)?t:parseFloat(t)||0}),[[Boolean,"boolean","bool"],[Number,"number","num"],[String,"string","str"],[t=>{const[e]=h(t);return M({[e]:Function.apply(null,[].concat(t[e]))})},"function","fn"]].forEach(([t,e,...n])=>{const r=t=>typeof t===e;B([e,...n],{check:(t,e)=>e?p.call(t,r):r(t),cast:e=>r(e)?e:t(e)})}),t.as=t=>{const{_:e,value:n}=U(t);return e.cast(n)},t.define=B,t.enums=(...t)=>{const n=n=>{const r=[],s=Symbol(n),l=c(null,{toString:{value:()=>s}});for(const e of t){const t="string"==typeof e,n=t?e:h(e)[0],s=t?Symbol(e):e[n];l[n]=s,r.push(s)}return o(d,n,{configurable:!0,value:a(l)}),{check(t,e){return e?p.call(t,t=>this.check(t,!1)):r.some(e=>i(e,t))},cast(t){return e&&!this.check(t,!1)&&$("enum",t),t}}};return S.add(n),n},t.fn=M,t.is=x,t.struct=(...t)=>{class r{constructor(t){if(e){for(const e of l)this[e]=t[e];for(const e of i)e in t&&(this[e]=t[e])}else for(const e in t)this[e]=t[e];return e?a(this):this}}const{prototype:s}=r,i=[],l=[];for(let r=0;r<t.length;r++){const{type:c,value:a}=U(t[r]);if("string"==typeof a||n(a))for(const t of[].concat(a))l.push(t),_(s,t,c,void 0);else{const[t]=h(a),n=a[t];"function"==typeof n?o(s,t,{value:M({[c]:n})}):(e&&!x({[c]:n})&&$(c,n),i.push(t),_(s,t,c,n))}}return o(s,"toJSON",{value(){const t=c(null);for(const e in this)t[e]=this[e];return t}}),A.add(r),r},t.union=O,t.unsafe=()=>{e=!1},t}({});
