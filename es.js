self.deejs=function(t){"use strict";
/*!
   * ISC License
   *
   * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */let e=!0;const{isArray:n,prototype:r}=Array,{assign:s,create:c,defineProperty:o,freeze:a,is:i,prototype:u}=Object,{getPrototypeOf:l,ownKeys:h}=Reflect,{concat:f,every:p,filter:y,map:d,push:g,slice:w,splice:k}=r,b="object"==typeof self?self:global,v=new Map,m=new Map,S=new Set,A=new Set,E=new WeakSet,I=t=>String(t).toString(),$=t=>String(t).replace(/^Symbol\(([\s\S]+)\)$/,"[$1]"),F=t=>{const[e]=h(t),n=t[e],r=v.get(e);if(!r)throw new TypeError("unknown type "+$(e));return{_:r,type:e,value:n}},U=(t,e)=>{const r=n(e),s=`expected type ${$(t)} but got ${[r?"array":typeof e,r?d.call(e,I):I(e)].join(": ")}`;throw new TypeError(s)},j=(t,e,n,r,s)=>{o(t,n,{value:(...n)=>T(N(r.apply(t,n),e,s),e,s)})},N=(t,n,r)=>(e&&(j(t,n,"concat",f,r),j(t,n,"filter",y,r),j(t,n,"map",d,r),j(t,n,"slice",w,r),o(t,"push",{value:(...e)=>(r.check(e,!0)||U(n,e),g.apply(t,e))}),o(t,"splice",{value(e,s=0,...c){return r.check(c,!0)||U(n,c),T(N(k.apply(t,arguments),n,r),n,r)}})),t),T=(t,n,r)=>(e&&E.add(t=new Proxy(t,{set(t,e,s){if(r.check(s,!1)||U(n,s),t.length<=e)throw new Error("out of bounds: use push(...values) instead");return t[e]=s,!0}})),t),_=(t,n,r,s)=>{const c=new WeakMap;o(t,n,{enumerable:!0,get(){return c.has(this)?c.get(this):s},set(t){e&&!x({[r]:t})&&U(r,t),c.set(this,t)}})},x=t=>{const{_:e,type:n,value:r}=F(t);return e.check(r,"symbol"==typeof n)},B=(t,r)=>{const c=r===O,a=!c&&S.has(r),i=!c&&!a&&A.has(r);if(!(c||a||i||r.check&&r.cast))throw new Error(`unable to define ${t} without check and cast`);for(const h of[].concat(t)){const t=/^(?:void|undefined)$/.test(h);if(v.has(h)||h in u||h in b&&!t)throw new TypeError($(h)+" already defined");const f=c||a?r(h):i?{check(t,e){return e?p.call(t,t=>this.check(t,!1)):t instanceof r||l(t)===u},cast:t=>t instanceof r?t:new r(t)}:s({},r),y=a?b[h].toString():Symbol(h);a||t||o(b,h,{configurable:!0,value:y}),v.set(h,f),o(u,h,{configurable:!0,get(){return e&&!f.check(this,!1)&&U(h,this),i?f.cast(this):this}}),t||(v.set(y,f),o(u,y,{configurable:!0,get(){if(e&&!f.check(this,!0)&&U(y,this),m.has(h))return f.cast(this);if(e&&!n(this)&&U(y,this),e&&E.has(this))return this;const t=i?d.call(this,f.cast,f):this;return T(N(t,y,f),h,f)}}))}},M=t=>{const[n]=h(t),r=t[n];return function(){const t=r.apply(this,arguments);return e&&!x({[n]:t})&&U(n,t),t}},O=t=>{const n=t.split("_");if(e&&!n.every(t=>v.has(t)))throw new TypeError("unable to define union: "+t);return{check(t,e){return e?p.call(t,t=>this.check(t,!1)):n.some(e=>x({[e]:t}))},cast(e){const r=n.findIndex(t=>x({[t]:e}));return r<0&&U(t,e),v.get(n[r]).cast(e)}}};return[{f32:"Float32Array"},{f64:"Float64Array"},{i8:"Int8Array"},{i16:"Int16Array"},{i32:"Int32Array"},{u8:"Uint8Array"},{u16:"Uint16Array"},{u32:"Uint32Array"},{uc8:"Uint8ClampedArray"},{i64:"BigInt64Array"},{u64:"BigUint64Array"},{double:"Float64Array"}].forEach(t=>{const[e]=h(t),r=b[t[e]];if(r){m.set(e,r);const t=new r(1);B(e,{check:(e,s)=>s?e instanceof r||n(e)&&p.call(new r(e),t=>!isNaN(t)):(t[0]=e,i(t[0],e)),cast:e=>"number"==typeof e?(t[0]=e,t[0]):e instanceof r?e:new r(e)})}}),B("int",{check(t,e){return e?p.call(t,t=>this.check(t,!1)):i(this.cast(t),t)},cast:t=>i(t,-0)?t:parseInt(t,10)||0}),B("float",{check(t,e){return e?p.call(t,t=>this.check(t,!1)):i(this.cast(t),t)},cast:t=>i(t,-0)?t:parseFloat(t)||0}),[[Boolean,"boolean","bool"],[Number,"number","num"],[String,"string","str"],[t=>{const[e]=h(t);return M({[e]:Function.apply(null,[].concat(t[e]))})},"function","fn"],[()=>{},"undefined","void"]].forEach(([t,e,...n])=>{const r=t=>typeof t===e;B([e,...n],{check:(t,e)=>e?p.call(t,r):r(t),cast:e=>r(e)?e:t(e)})}),t.as=t=>{const{_:e,value:n}=F(t);return e.cast(n)},t.define=B,t.enums=(...t)=>{const n=n=>{const r=[],s=Symbol(n),u=c(null,{toString:{value:()=>s}});for(const e of t){const t="string"==typeof e,n=t?e:h(e)[0],s=t?Symbol(e):e[n];u[n]=s,r.push(s)}return o(b,n,{configurable:!0,value:a(u)}),{check(t,e){return e?p.call(t,t=>this.check(t,!1)):r.some(e=>i(e,t))},cast(t){return e&&!this.check(t,!1)&&U("enum",t),t}}};return S.add(n),n},t.fn=M,t.is=x,t.struct=(...t)=>{class r{constructor(t){if(e){for(const e of u)this[e]=t[e];for(const e of i)e in t&&(this[e]=t[e])}else for(const e in t)this[e]=t[e];return e?a(this):this}}const{prototype:s}=r,i=[],u=[];for(let r=0;r<t.length;r++){const{type:c,value:a}=F(t[r]);if("string"==typeof a||n(a))for(const t of[].concat(a))u.push(t),_(s,t,c,void 0);else{const[t]=h(a),n=a[t];"function"==typeof n?o(s,t,{value:M({[c]:n})}):(e&&!x({[c]:n})&&U(c,n),i.push(t),_(s,t,c,n))}}return o(s,"toJSON",{value(){const t=c(null);for(const e in this)t[e]=this[e];return t}}),A.add(r),r},t.union=O,t.unsafe=()=>{e=!1},t}({});
