self.deejs=function(t){"use strict";
/*!
   * ISC License
   *
   * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */let e=!0;const n=/^[^(]*\(\s*([^\2]*?)(\s*\)\s*(?:=>)?\s*\{)([\s\S]*?)\}$/,r=/^Symbol\(([\s\S]+)\)$/,{isArray:s,prototype:c}=Array,{parse:o}=JSON,{assign:a,create:i,defineProperty:l,freeze:u,is:h,prototype:f}=Object,{getPrototypeOf:p,ownKeys:y}=Reflect,{concat:g,every:d,filter:w,map:b,push:k,slice:S,splice:v}=c,m="object"==typeof self?self:global,A=new Map,$=new Map,E=new Set,N=new Set,O=new WeakSet,I=new Proxy({},{get:()=>{}}),j=t=>String(t).toString(),x=t=>String(t).replace(r,"[$1]"),F=t=>{const[e]=y(t),n=t[e],r=A.get(e);if(!r)throw new TypeError("unknown type "+x(e));return{_:r,type:e,value:n}},J=(t,e)=>{const n=s(e),r=`expected type ${x(t)} but got ${[n?"array":typeof e,n?b.call(e,j):j(e)].join(": ")}`;throw new TypeError(r)},U=(t,e,n,r,s)=>{l(t,n,{value:(...n)=>T(P(r.apply(t,n),e,s),e,s)})},P=(t,n,r)=>(e&&(U(t,n,"concat",g,r),U(t,n,"filter",w,r),U(t,n,"map",b,r),U(t,n,"slice",S,r),l(t,"push",{value:(...e)=>(r.check(e,!0)||J(n,e),k.apply(t,e))}),l(t,"splice",{value(e,s=0,...c){return r.check(c,!0)||J(n,c),T(P(v.apply(t,arguments),n,r),n,r)}})),t),T=(t,n,r)=>(e&&O.add(t=new Proxy(t,{set(t,e,s){if(r.check(s,!1)||J(n,s),t.length<=e)throw new Error("out of bounds: use push(...values) instead");return t[e]=s,!0}})),t),_=(t,n,r,s)=>{const c=new WeakMap;l(t,n,{enumerable:!0,get(){return c.has(this)?c.get(this):s},set(t){e&&!M({[r]:t})&&J(r,t),c.set(this,t)}})},B=t=>{const{_:e,value:n}=F(t);return e.cast(n)},M=t=>{const{_:e,type:n,value:r}=F(t);return e.check(r,"symbol"==typeof n)},R=(t,n)=>{const r=n===z,c=!r&&E.has(n),o=!r&&!c&&N.has(n);if(!(r||c||o||n.check&&n.cast))throw new Error(`unable to define ${t} without check and cast`);for(const i of[].concat(t)){const t=/^(?:void|undefined)$/.test(i);if(A.has(i)||i in f||i in m&&!t)throw new TypeError(x(i)+" already defined");const u=r||c?n(i):o?{check(t,e){return e?d.call(t,t=>this.check(t,!1)):t instanceof n||p(t)===f},cast:t=>t instanceof n?t:new n(t)}:a({},n),h=c?m[i].toString():Symbol(i);c||t||l(m,i,{configurable:!0,value:h}),A.set(i,u),l(f,i,{configurable:!0,get(){return e&&!u.check(this,!1)&&J(i,this),o?u.cast(this):this}}),t||(A.set(h,u),l(f,h,{configurable:!0,get(){if(e&&!u.check(this,!0)&&J(h,this),$.has(i))return u.cast(this);if(e&&!s(this)&&J(h,this),e&&O.has(this))return this;const t=o?b.call(this,u.cast,u):this;return T(P(t,h,u),i,u)}}))}},W=t=>{const[r]=y(t),s=t[r],{length:c}=s;return l(o,"toJSON",{value(){const t=String(s),e=t.replace(n,"$1"),c=t.replace(n,"$3");return{["ÿ"+String(r)]:[e.trim(),c.trim()]}}}),o;function o(...t){for(let e=0,{length:n}=t;e<c;e++)n<=e&&(t[e]=I);const n=s.apply(this,t);return e&&!M({[r]:n})&&J(r,n),n}},z=t=>{const n=t.split("_");if(e&&!n.every(t=>A.has(t)))throw new TypeError("unable to define union: "+t);return{check(t,e){return e?d.call(t,t=>this.check(t,!1)):n.some(e=>M({[e]:t}))},cast(e){const r=n.findIndex(t=>M({[t]:e}));return r<0&&J(t,e),A.get(n[r]).cast(e)}}};return l(JSON,"parse",{value:(t,e=((t,e)=>e))=>o.call(JSON,t,(function(t,n){if("object"==typeof n&&n){const t=y(n);if(1===t.length){let[e]=t;"ÿ"===e[0]&&s(n[e])&&(e=e.slice(1),/^Symbol\((.+?)\)$/.test(e)&&(e=m[RegExp.$1]),n=B({fn:{[e]:n[t]}}))}}return e.call(this,t,n)}))}),[{f32:"Float32Array"},{f64:"Float64Array"},{i8:"Int8Array"},{i16:"Int16Array"},{i32:"Int32Array"},{u8:"Uint8Array"},{u16:"Uint16Array"},{u32:"Uint32Array"},{uc8:"Uint8ClampedArray"},{i64:"BigInt64Array"},{u64:"BigUint64Array"},{double:"Float64Array"}].forEach(t=>{const[e]=y(t),n=m[t[e]];if(n){$.set(e,n);const t=new n(1);R(e,{check:(e,r)=>r?e instanceof n||s(e)&&d.call(new n(e),t=>!isNaN(t)):(t[0]=e,h(t[0],e)),cast:e=>"number"==typeof e?(t[0]=e,t[0]):e instanceof n?e:new n(e)})}}),R("int",{check(t,e){return e?d.call(t,t=>this.check(t,!1)):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseInt(t,10)||0}),R("float",{check(t,e){return e?d.call(t,t=>this.check(t,!1)):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseFloat(t)||0}),[[Boolean,"boolean","bool"],[Number,"number","num"],[String,"string","str"],[t=>{const[e]=y(t);return W({[e]:Function.apply(null,[].concat(t[e]))})},"function","fn"],[()=>{},"undefined","void"]].forEach(([t,e,...n])=>{const r=t=>typeof t===e;R([e,...n],{check:(t,e)=>e?d.call(t,r):r(t),cast:e=>r(e)?e:t(e)})}),t.as=B,t.define=R,t.enums=(...t)=>{const n=n=>{const r=[],s=Symbol(n),c=i(null,{toString:{value:()=>s}});for(const e of t){const t="string"==typeof e,n=t?e:y(e)[0],s=t?Symbol(e):e[n];c[n]=s,r.push(s)}return l(m,n,{configurable:!0,value:u(c)}),{check(t,e){return e?d.call(t,t=>this.check(t,!1)):r.some(e=>h(e,t))},cast(t){return e&&!this.check(t,!1)&&J("enum",t),t}}};return E.add(n),n},t.fn=W,t.is=M,t.struct=(...t)=>{class n{constructor(t){if(e){for(const e of o)this[e]=t[e];for(const e of c)e in t&&(this[e]=t[e])}else for(const e in t)this[e]=t[e];return e?u(this):this}}const{prototype:r}=n,c=[],o=[];for(let n=0;n<t.length;n++){const{type:a,value:i}=F(t[n]);if("string"==typeof i||s(i))for(const t of[].concat(i))o.push(t),_(r,t,a,void 0);else{const[t]=y(i),n=i[t];"function"==typeof n?l(r,t,{value:W({[a]:n})}):(e&&!M({[a]:n})&&J(a,n),c.push(t),_(r,t,a,n))}}return l(r,"toJSON",{value(){const t=i(null);for(const e in this)t[e]=this[e];return t}}),N.add(n),n},t.union=z,t.unsafe=()=>{e=!1},t}({});
