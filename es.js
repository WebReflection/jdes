self.deejs=function(t){"use strict";
/*!
   * ISC License
   *
   * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */let e=!0;const n=/^[^(]*\(\s*([^\2]*?)(\s*\)\s*(?:=>)?\s*\{)([\s\S]*?)\}$/,r=/^Symbol\(([\s\S]+)\)$/,{isArray:c,prototype:s}=Array,{parse:o}=JSON,{assign:a,create:i,defineProperty:l,freeze:u,is:h,prototype:f}=Object,{getPrototypeOf:p,ownKeys:y}=Reflect,{concat:d,every:g,filter:b,map:w,push:k,slice:S,splice:m}=s,v="object"==typeof self?self:global,A=new Map,$=new Map,j=new Set,E=new Set,O=new WeakSet,N=new Proxy({},{get:()=>{}}),I=t=>String(t).toString(),x=t=>String(t).replace(r,"[$1]"),F=t=>{const[e]=y(t),n=t[e],r=A.get(e);if(!r)throw new TypeError("unknown type "+x(e));return{_:r,type:e,value:n}},J=(t,e)=>{const n=c(e),r=`expected type ${x(t)} but got ${[n?"array":typeof e,n?w.call(e,I):I(e)].join(": ")}`;throw new TypeError(r)},M=(t,e,n,r,c)=>{l(t,n,{value:(...n)=>P(U(r.apply(t,n),e,c),e,c)})},U=(t,n,r)=>(e&&(M(t,n,"concat",d,r),M(t,n,"filter",b,r),M(t,n,"map",w,r),M(t,n,"slice",S,r),l(t,"push",{value:(...e)=>(r.check(e,!0)||J(n,e),k.apply(t,e))}),l(t,"splice",{value(e,c=0,...s){return r.check(s,!0)||J(n,s),P(U(m.apply(t,arguments),n,r),n,r)}})),t),P=(t,n,r)=>(e&&O.add(t=new Proxy(t,{set(t,e,c){if(r.check(c,!1)||J(n,c),t.length<=e)throw new Error("out of bounds: use push(...values) instead");return t[e]=c,!0}})),t),T=(t,n,r,c)=>{const s=new WeakMap;l(t,n,{enumerable:!0,get(){return s.has(this)?s.get(this):c},set(t){e&&!B({[r]:t})&&J(r,t),s.set(this,t)}})},_=t=>{const{_:e,value:n}=F(t);return e.cast(n)},B=t=>{const{_:e,type:n,value:r}=F(t);return e.check(r,"symbol"==typeof n)},R=(t,n)=>{const r=n===z,s=!r&&j.has(n),o=!r&&!s&&E.has(n);if(!(r||s||o||n.check&&n.cast))throw new Error(`unable to define ${t} without check and cast`);for(const i of[].concat(t)){const t=/^(?:void|undefined)$/.test(i);if(A.has(i)||i in f||i in v&&!t)throw new TypeError(x(i)+" already defined");const u=r||s?n(i):o?{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):t instanceof n||p(t)===f},cast:t=>t instanceof n?t:new n(t)}:a({},n),h=s?v[i].toString():Symbol(i);s||t||l(v,i,{configurable:!0,value:h}),A.set(i,u),l(f,i,{configurable:!0,get(){return e&&!u.check(this,!1)&&J(i,this),o?u.cast(this):this}}),t||(A.set(h,u),l(f,h,{configurable:!0,get(){if(e&&!u.check(this,!0)&&J(h,this),$.has(i))return u.cast(this);if(e&&!c(this)&&J(h,this),e&&O.has(this))return this;const t=o?w.call(this,u.cast,u):this;return P(U(t,h,u),i,u)}}))}},W=t=>{const[r]=y(t),c=t[r],{length:s}=c;return l(o,"toJSON",{value(){const t=String(c),e=t.replace(n,"$1"),s=t.replace(n,"$3");return{["ÿ"+String(r)]:[e.trim(),s.trim()]}}}),o;function o(...t){for(let e=0,{length:n}=t;e<s;e++)n<=e&&(t[e]=N);const n=c.apply(this,t);return e&&!B({[r]:n})&&J(r,n),n}},z=t=>{const n=t.split("_");if(e&&!g.call(n,(t=>A.has(t))))throw new TypeError("unable to define union: "+t);return{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):n.some((e=>B({[e]:t})))},cast(e){const r=n.findIndex((t=>B({[t]:e})));return r<0&&J(t,e),A.get(n[r]).cast(e)}}};return l(JSON,"parse",{value:(t,e=((t,e)=>e))=>o.call(JSON,t,(function(t,n){if("object"==typeof n&&n){const t=y(n);if(1===t.length){let[e]=t;"ÿ"===e[0]&&c(n[e])&&(e=e.slice(1),/^Symbol\((.+?)\)$/.test(e)&&(e=v[RegExp.$1]),n=_({fn:{[e]:n[t]}}))}}return e.call(this,t,n)}))}),[{f32:"Float32Array"},{f64:"Float64Array"},{i8:"Int8Array"},{i16:"Int16Array"},{i32:"Int32Array"},{u8:"Uint8Array"},{u16:"Uint16Array"},{u32:"Uint32Array"},{uc8:"Uint8ClampedArray"},{i64:"BigInt64Array"},{u64:"BigUint64Array"},{double:"Float64Array"}].forEach((t=>{const[e]=y(t),n=v[t[e]];if(n){$.set(e,n);const t=new n(1);R(e,{check:(e,r)=>r?e instanceof n||c(e)&&g.call(new n(e),(t=>!isNaN(t))):(t[0]=e,h(t[0],e)),cast:e=>"number"==typeof e?(t[0]=e,t[0]):e instanceof n?e:new n(e)})}})),R("int",{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseInt(t,10)||0}),R("float",{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseFloat(t)||0}),[[Boolean,"boolean","bool"],[Number,"number","num"],[String,"string","str"],[t=>{const[e]=y(t);return W({[e]:Function.apply(null,[].concat(t[e]))})},"function","fn"],[()=>{},"undefined","void"]].forEach((([t,e,...n])=>{const r=t=>typeof t===e;R([e,...n],{check:(t,e)=>e?g.call(t,r):r(t),cast:e=>r(e)?e:t(e)})})),R(["object","obj"],{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):"object"==typeof t&&t instanceof Object},cast:Object}),t.as=_,t.define=R,t.enums=(...t)=>{const n=n=>{const r=[],c=Symbol(n),s=i(null,{toString:{value:()=>c}});for(const e of t){const t="string"==typeof e,n=t?e:y(e)[0],c=t?Symbol(e):e[n];s[n]=c,r.push(c)}return l(v,n,{configurable:!0,value:u(s)}),{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):r.some((e=>h(e,t)))},cast(t){return e&&!this.check(t,!1)&&J("enum",t),t}}};return j.add(n),n},t.fn=W,t.is=B,t.map=(t,n)=>()=>{const r=e?function(e){const r=new Map,{set:c}=r;if(r.set=function(e,r){return B({[t]:e})||J(t,e),B({[n]:r})||J(n,r),c.call(this,e,r)},e)for(let t=0;t<e.length;t++){const n=e[t];r.set(n[0],n[1])}return r}:Map;return E.add(r),r},t.set=t=>()=>{const n=e?function(e){const n=new Set,{add:r}=n;if(n.add=function(e){return B({[t]:e})||J(t,e),r.call(this,e)},e)for(let t=0;t<e.length;t++)n.add(e[t]);return n}:Set;return E.add(n),n},t.struct=(...t)=>{class n{constructor(t){if(e){for(const e of s)this[e]=t[e];for(const e of c)e in t&&(this[e]=t[e])}else for(const e in t)this[e]=t[e];return e?u(this):this}}const{prototype:r}=n,c=[],s=[];for(let n=0;n<t.length;n++){const{type:o,value:a}=F(t[n]);for(const t of[].concat(a))if("string"==typeof t)s.push(t),T(r,t,o,void 0);else{const[n]=y(t),s=t[n];"function"==typeof s?l(r,n,{value:W({[o]:s})}):(e&&!B({[o]:s})&&J(o,s),c.push(n),T(r,n,o,s))}}return l(r,"toJSON",{value(){const t=i(null);for(const e in this)t[e]=this[e];return t}}),E.add(n),n},t.union=z,t.unsafe=()=>{e=!1},t}({});
