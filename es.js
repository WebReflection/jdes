self.deejs=function(t){"use strict";
/*!
   * ISC License
   *
   * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
   * PERFORMANCE OF THIS SOFTWARE.
   */let e=!0;const n=/^[^(]*\(\s*([^\2]*?)(\s*\)\s*(?:=>)?\s*\{)([\s\S]*?)\}$/,s=/^Symbol\(([\s\S]+)\)$/,{isArray:r,prototype:c}=Array,{parse:o}=JSON,{assign:a,create:i,defineProperty:l,freeze:u,is:h,prototype:f}=Object,{getPrototypeOf:p,ownKeys:y}=Reflect,{concat:d,every:g,filter:w,map:b,push:k,slice:S,splice:v}=c,m="object"==typeof self?self:global,A=new Map,$=new Map,j=new Set,E=new Set,O=new Set,N=new WeakSet,M=new Proxy({},{get:()=>{}}),I=t=>String(t).toString(),x=t=>String(t).replace(s,"[$1]"),F=t=>r(t)?t[0]:y(m).filter((e=>m[e]===t))[0],J=t=>{const[e]=y(t),n=t[e],s=A.get(e);if(!s)throw new TypeError("unknown type "+x(e));return{_:s,type:e,value:n}},U=(t,e)=>{const n=r(e),s=`expected type ${x(t)} but got ${[n?"array":typeof e,n?b.call(e,I):I(e)].join(": ")}`;throw new TypeError(s)},P=(t,e,n,s,r)=>{l(t,n,{value:(...n)=>W(T(s.apply(t,n),e,r),e,r)})},T=(t,n,s)=>(e&&(P(t,n,"concat",d,s),P(t,n,"filter",w,s),P(t,n,"map",b,s),P(t,n,"slice",S,s),l(t,"push",{value:(...e)=>(s.check(e,!0)||U(n,e),k.apply(t,e))}),l(t,"splice",{value(e,r=0,...c){return s.check(c,!0)||U(n,c),W(T(v.apply(t,arguments),n,s),n,s)}})),t),W=(t,n,s)=>(e&&N.add(t=new Proxy(t,{set(t,e,r){if(s.check(r,!1)||U(n,r),t.length<=e)throw new Error("out of bounds: use push(...values) instead");return t[e]=r,!0}})),t),_=(t,n,s,r)=>{const c=new WeakMap;l(t,n,{enumerable:!0,get(){return c.has(this)?c.get(this):r},set(t){e&&!R({[s]:t})&&U(s,t),c.set(this,t)}})},B=t=>{const{_:e,value:n}=J(t);return e.cast(n)},R=t=>{const{_:e,type:n,value:s}=J(t);return e.check(s,"symbol"==typeof n)},z=(t,n)=>{const s=n===K,c=!s&&j.has(n),o=!s&&!c&&E.has(n),i=!s&&!c&&!o&&O.has(n);if(!(s||c||o||i||n.check&&n.cast))throw new Error(`unable to define ${t} without check and cast`);for(const u of[].concat(t)){const t=/^(?:void|undefined)$/.test(u);if(A.has(u)||u in f||u in m&&!t)throw new TypeError(x(u)+" already defined");const h=s||c?n(u):o?{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):t instanceof n||p(t)===f},cast:t=>t instanceof n?t:new n(t)}:i?{check(t,s){return s?g.call(t,(t=>this.check(t,!1))):(e?n.instances.has(t):t instanceof n)||r(t)},cast:t=>(e?n.instances.has(t):t instanceof n)?t:new n(t)}:a({},n),y=c?m[u].toString():Symbol(u);c||t||l(m,u,{configurable:!0,value:y}),A.set(u,h),l(f,u,{configurable:!0,get(){return e&&!h.check(this,!1)&&U(u,this),o||i?h.cast(this):this}}),t||(A.set(y,h),l(f,y,{configurable:!0,get(){if(e&&!h.check(this,!0)&&U(y,this),$.has(u))return h.cast(this);if(e&&!r(this)&&U(y,this),e&&N.has(this))return this;const t=o||i?b.call(this,h.cast,h):this;return W(T(t,y,h),u,h)}}))}},C=t=>{const[s]=y(t),r=t[s],{length:c}=r;return l(o,"toJSON",{value(){const t=String(r),e=t.replace(n,"$1"),c=t.replace(n,"$3");return{["ÿ"+String(s)]:[e.trim(),c.trim()]}}}),o;function o(...t){for(let e=0,{length:n}=t;e<c;e++)n<=e&&(t[e]=M);const n=r.apply(this,t);return e&&!R({[s]:n})&&U(s,n),n}},K=t=>{const n=t.split("_");if(e&&!g.call(n,(t=>A.has(t))))throw new TypeError("unable to define union: "+t);return{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):n.some((e=>R({[e]:t})))},cast(e){const s=n.findIndex((t=>R({[t]:e})));return s<0&&U(t,e),A.get(n[s]).cast(e)}}};return l(JSON,"parse",{value:(t,e=((t,e)=>e))=>o.call(JSON,t,(function(t,n){if("object"==typeof n&&n){const t=y(n);if(1===t.length){let[e]=t;"ÿ"===e[0]&&r(n[e])&&(e=e.slice(1),/^Symbol\((.+?)\)$/.test(e)&&(e=m[RegExp.$1]),n=B({fn:{[e]:n[t]}}))}}return e.call(this,t,n)}))}),[{f32:"Float32Array"},{f64:"Float64Array"},{i8:"Int8Array"},{i16:"Int16Array"},{i32:"Int32Array"},{u8:"Uint8Array"},{u16:"Uint16Array"},{u32:"Uint32Array"},{uc8:"Uint8ClampedArray"},{i64:"BigInt64Array"},{u64:"BigUint64Array"},{double:"Float64Array"}].forEach((t=>{const[e]=y(t),n=m[t[e]];if(n){$.set(e,n);const t=new n(1);z(e,{check:(e,s)=>s?e instanceof n||r(e)&&g.call(new n(e),(t=>!isNaN(t))):(t[0]=e,h(t[0],e)),cast:e=>"number"==typeof e?(t[0]=e,t[0]):e instanceof n?e:new n(e)})}})),z("int",{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseInt(t,10)||0}),z("float",{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):h(this.cast(t),t)},cast:t=>h(t,-0)?t:parseFloat(t)||0}),[[Boolean,"boolean","bool"],[Number,"number","num"],[String,"string","str"],[t=>{const[e]=y(t);return C({[e]:Function.apply(null,[].concat(t[e]))})},"function","fn"],[()=>{},"undefined","void"]].forEach((([t,e,...n])=>{const s=t=>typeof t===e;z([e,...n],{check:(t,e)=>e?g.call(t,s):s(t),cast:e=>s(e)?e:t(e)})})),z(["object","obj"],{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):"object"==typeof t&&t instanceof Object},cast:Object}),t.as=B,t.define=z,t.enums=(...t)=>{const n=n=>{const s=[],r=Symbol(n),c=i(null,{toString:{value:()=>r}});for(const e of t){const t="string"==typeof e,n=t?e:y(e)[0],r=t?Symbol(e):e[n];c[n]=r,s.push(r)}return l(m,n,{configurable:!0,value:u(c)}),{check(t,e){return e?g.call(t,(t=>this.check(t,!1))):s.some((e=>h(e,t)))},cast(t){return e&&!this.check(t,!1)&&U("enum",t),t}}};return j.add(n),n},t.fn=C,t.is=R,t.map=(t,n)=>{const s=F(t),r=F(n),c=e?function(e){const o=new Map,{set:a}=o;l(o,"set",{value(e,c){return R({[s]:e})||U(t,e),R({[r]:c})||U(n,c),a.call(this,e,c)}});for(let t=0;t<e.length;t++){const n=e[t];o.set(n[0],n[1])}return c.instances.set(o,!0),o}:Map;return O.add(c),e&&(c.instances=new WeakMap),c},t.set=t=>{const n=F(t),s=e?function(e){const r=new Set,{add:c}=r;l(r,"add",{value(e){return R({[n]:e})||U(t,e),c.call(this,e)}});for(let t=0;t<e.length;t++)r.add(e[t]);return s.instances.set(r,!0),r}:Set;return O.add(s),e&&(s.instances=new WeakMap),s},t.struct=(...t)=>{class n{constructor(t){if(e){for(const e of c)this[e]=t[e];for(const e of r)e in t&&(this[e]=t[e])}else for(const e in t)this[e]=t[e];return e?u(this):this}}const{prototype:s}=n,r=[],c=[];for(let n=0;n<t.length;n++){const{type:o,value:a}=J(t[n]);for(const t of[].concat(a))if("string"==typeof t)c.push(t),_(s,t,o,void 0);else{const[n]=y(t),c=t[n];"function"==typeof c?l(s,n,{value:C({[o]:c})}):(e&&!R({[o]:c})&&U(o,c),r.push(n),_(s,n,o,c))}}return l(s,"toJSON",{value(){const t=i(null);for(const e in this)t[e]=this[e];return t}}),E.add(n),n},t.union=K,t.unsafe=()=>{e=!1},t}({});
